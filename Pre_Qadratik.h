#include <stdio.h>
#include <locale.h>
#include <limits.h>
#include <float.h>
#include <math.h>
#include <stdbool.h>
#include <assert.h>

#define MIN_DELT 0.00001              ///< Значение, которое обозначает минимальное значение модуля не нулевого числа
#define NUM_AF_POINT 4                ///< Количество цифр после запятой при выводе
#define NUM_OF_COEF 3                 ///< Количество коэфициентов

//Характеристики юнитеста reshalka
#define NUM_OF_COEF_RESHALKA 3        ///< Количество коэфициентов в reshalka
#define NUM_OF_UNITEST_RESHALKA 6     ///< Количество юнитестов reshalka
#define NUM_OUT_OF_UNITEST_RESHALKA 3 ///< Количество выводов функции reshalka

//Характеристики юнитеста qadrat
#define NUM_OF_COEF_QADRAT 3        ///< Количество коэфициентов в qadrat
#define NUM_OF_UNITEST_QADRAT 3     ///< Количество юнитестов qadrat
#define NUM_OUT_OF_UNITEST_QADRAT 3 ///< Количество выводов функции qadrat

//Характеристики юнитеста linerial
#define NUM_OF_COEF_LINERIAL 2        ///< Количество коэфициентов в linerial
#define NUM_OF_UNITEST_LINERIAL 3     ///< Количество юнитестов linerial
#define NUM_OUT_OF_UNITEST_LINERIAL 2 ///< Количество выводов функции linerial

const char* NAME_VAR[NUM_OF_COEF] = {"a","b","c"};///< Список имён переменных
const char END_SIMVOL = '#'; ///< Символ при вводе которого завершается программа

/// Варианты вывода функций reshalka, qadrat
enum Error_reshalka
{
    ROOTS_2 = 2,         ///< Уравнение имеет 2 корня
    ROOTS_1 = 1,         ///< Уравнение имеет 1 корень
    ROOTS_0 = 0,         ///< У уравнения нет корней
    ROOTS_INF = -1,      ///< Уравнение имеет бесконечность решений
    OVERFLOW_DIS = -2,   ///< Ошибка: Дискриминант при решении уравнения переполнелся
    ERROR = -3           ///< Ошибка: Непредвиденное состояние ( не должно выводиться, но есть для диагностики неутённых состояний, которые может вывести функция после будущих изменений)
};

/// Варианты вывода функций abc_scan skan_variable
enum Error_skan_var
{
    OK = 0,              ///< С вводом всё хорошо
    END_PROGRAM = 1,     ///< Нужно завершить программу
    NEED_TAKE_STOK = 2   ///< Нужно подытожить коэфициенрты уравнения
};

//=====================================================================================
/// Ввод для юнитеста reshalka
const double UNITEST_IN_RESHALKA[NUM_OF_UNITEST_RESHALKA][NUM_OF_COEF_RESHALKA] =
    {
    {0, 0, 0},     // Поверка на уникальный случай бесконечности корней
    {0, 0, 1},     // Проверка на отсутствие корней
    {0, 1, 1},     // Проверка на решение линейных уравнений
    {1, -2, 1},    // Проверка на квадратное уравнение с 1 корнем
    {1, -1, -2},   // Проверка на квадратное уравнение с 2 корнями
    {1, 1, 1},     // проверка на отсутствие корней
    };

/// Ожидаемый вывод для юнитеста reshalka
const double UNITEST_OUT_RESHALKA[NUM_OF_UNITEST_RESHALKA][NUM_OUT_OF_UNITEST_RESHALKA] =
    {
    {0, 0, ROOTS_INF},
    {0, 0, ROOTS_0},
    {-1, 0, ROOTS_1},
    {1, 0, ROOTS_1},
    {2, -1, ROOTS_2},
    {0, 0, ROOTS_0},
    };

//=====================================================================================
/// Ввод для юнитеста qadrat
const double UNITEST_IN_QADRAT[NUM_OF_UNITEST_QADRAT][NUM_OF_COEF_QADRAT] =
    {
    {1, -2, 1},    // Проверка на квадратное уравнение с 1 корнем
    {1, -1, -2},   // Проверка на квадратное уравнение с 2 корнями
    {1, 1, 1},     // проверка на отсутствие корней
    };

/// Ожидаемый вывод для юнитеста qadrat
const double UNITEST_OUT_QADRAT[NUM_OF_UNITEST_QADRAT][NUM_OUT_OF_UNITEST_QADRAT] =
    {
    {1, 0, ROOTS_1},
    {2, -1, ROOTS_2},
    {0, 0, ROOTS_0},
    };

//=====================================================================================
/// Ввод для юнитеста linerial
const double UNITEST_IN_LINERIAL[NUM_OF_UNITEST_LINERIAL][NUM_OF_COEF_LINERIAL] =
    {
    {0, 0},     // Поверка на уникальный случай бесконечности корней
    {0, 1},     // Проверка на отсутствие корней
    {1, 1},     // Проверка на решение линейных уравнений
    };

/// Ожидаемый вывод для юнитеста linerial
const double UNITEST_OUT_LINERIAL[NUM_OF_UNITEST_LINERIAL][NUM_OUT_OF_UNITEST_LINERIAL] =
    {
    {0, ROOTS_INF},
    {0, ROOTS_0},
    {-1, ROOTS_1},
    };

//=====================================================================================

/*!
Проводит тестирование функции reshalka
\return выводит в соответствии Error_skan_var
*/
int unitest_reshalka(void);

/*!
Проводит тестирование функции qadrat
\return выводит в соответствии Error_skan_var
*/
int unitest_qadrat(void);

/*!
Проводит тестирование функции linerial
\return выводит в соответствии Error_skan_var
*/
int unitest_linerial(void);

/*!
Вызывает все тестирования и оповещает о проблемах
\return выводит в соответствии Error_skan_var
*/
int unitest(void);

/*!
Оформляет ввод коефициентов и принимает их значение + отслеживает завершение программы
\param[out] *a,*b,*c double Указатели на переменные для хранения коэфициентов
\return в соответствии Error_skan_var
*/
int abc_scan(double* a, double* b, double* c);

/*!
Оформляет ввод некоторого значения и проверяет ввод на ошибки.
Так же она инициализирует завершение программы в зависимости от ввода.
\param[in] var_name строчка с названием переменной
\param[out] *var указатель на переменную для записи ввода
\return в соответствии Error_skan_var
*/
int skan_variable(const char var_name[], double* var);

/*!
Задаёт пользователю вопрос о завершении программы, анализирует ответ и выводит соответствующее значение
\return в соответствии Error_skan_var
*/
int end_question(void);

/*!
Проверяет значение на переполнение и выводит оповещающее сообщение (оно может меняться в зависимости от введённых параметров), если это произошло
\param[in] nom число на проверку
\param[in] befor_variable сообщение перед выводом названия переменной
\param[in] name_variable  название переменной
\param[in] after_variable сообщение после вывода названия переменной
\param[out] *overflow указатель на переменную для записи значения (true - если число переполнено folse - не записывается для удобности определения наличия переполненного числа при применении к группе чисел)
*/
void overflow_alarm (double nom, char befor_variable[], char name_variable[], char after_variable[], bool* overflow);

/*!
Проверяет коэфициенты уравнения на переполнение и выводит соответсвующее опровещение
\param a,b,c параметры уравнения
\return возвращает true если есть переполненое значение folse если - нет
*/
bool abc_lim_over_print(double a, double b, double c);

/*!
Проверяет корни уравнения на переполнение, выводит оповещение об этом или печатает сами корни.
\param x_1,x_2 корни уравнения
\param root_count количество корней (принимаемые значения соответствуют Error_reshalka)
*/
void x_lim_over_print(double x_1, double x_2, int root_count);

/*!
Решает квадратное уравнение
\param[in] a,b,c коэфициенты уравнения
\param[out] x_1,x_2 корни уравнения
\return соответствует Error_reshalka
*/
int qadrat ( double a, double b, double c, double* x_1, double* x_2);

/*!
Решает линейное уравнение
\param[in] b,c коэфициенты уравнения
\param[out] *x указатель на переменную для записи корня
\return соответствует Error_reshalka
*/
int linerial (double b, double c, double *x);

/*!
Решает квадратное/линейное уравнение, определяет бесконечность корней
\param[in] a,b,c коэфициенты уравнения
\param[out] *x_1, *x_2 указателb на переменную для записй корней
\return соответствует Error_reshalka
*/
int reshalka (double a, double b, double c, double* x_1, double* x_2);

/*!
Печатает шапку оформления программы
*/
void start_print();

/*!
Печатает печатает оповещение о завершении программы и задерживает закрытие
окна до нажатия [Enter]
*/
void end_print();
