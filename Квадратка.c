 #include <stdio.h>
 #include <locale.h>
 #include <stdbool.h>
 #include <limits.h>
 #include <float.h>
 #include <math.h>

 int abc_scan(float *a, float *b, float *c);
/*
==========================================================================
                int abc_scan(float *a, float *b, float *c)
==========================================================================
 Оформляет ввод днных и принимает их значение
==========================================================================
 Ввод:
 *a, *b, *c float  Ссылки на ячейки памяти в которые нужно записать
                   коэфициенты квадратных уравнений
 Вывод:
 printf            Выводит на экран всё для оформления ввода
 int      sk_chek  1 - если нужно завершить программу
                   0 - если программа должна продолжать выполняться
==========================================================================
*/
 int double_lim_over(double num);
/*
==========================================================================
                      int double_lim_over(double num)
==========================================================================
 Проверяет, переполнено число или нет
==========================================================================
 Ввод:
 num      double число для проверки
 Вывод:
 int      1 - если число переполнено
          0 - если нет
==========================================================================
*/
 int float_lim_over(float num);
/*
==========================================================================
                      int float_lim_over(float num)
==========================================================================
 Проверяет, переполнено число или нет
==========================================================================
 Ввод:
 num      float число для проверки
 Вывод:
 int      1 - если число переполнено
          0 - если нет
==========================================================================
*/
 int abc_lim_over_print(float a, float b, float c);
/*
==========================================================================
             int abc_lim_over_print(float a,float b,float c);
==========================================================================
 Проверяет a, b, c на переполнение и выводит оповещение пользователю о
 преполненых элементах
==========================================================================
 Ввод:
 a, b, c  float значения коэфициентов квадратного уравнения.
 Вывод:
 int      0 если нет переполненных элементов
          1 если есть
 printf   Печатает на экран предупреждение о слишком больших/малых
          введённых значениях
==========================================================================
*/
 void x_lim_over_print(double x_1, double x_2, int n);
/*
==========================================================================
            int x_lim_over_print(float x_1, float x_2, int n);
==========================================================================
 Проверяет x_1 x_2 на переполнение и выводит оповещение пользователю о
 преполненых элементах bkb x_1 x_2
==========================================================================
 Ввод:
 x_1, x_2 float значения коэфициентов квадратного уравнения.
 n        int   количество корней
 Вывод:
 int      0 если нет переполненных элементов
          1 если есть
 printf   Печатает на экран предупреждение о слишком больших значениях
          корней или выводит их
==========================================================================
*/
 int qadrat ( float a, float b, float c, double *x_1, double *x_2, int *n );
/*
==========================================================================
    int qadrat(float a, float b, float c, float x_1, float x_2, int n)
==========================================================================
 Решает ax^2+bx+c=0 и проверяет дискриминант на переполнение
==========================================================================
 Ввод:
 a, b, c    float значения коэфициентов квадратного уравнения
 *x_1, *x_2 float ссылки ячейки памяти, куда нужно записывать корни
                  уравнения
 *n         float ссылки ячейку памяти, куда нужно записывать количество
                  корней уравнения
 Вывод:
 float    Массив: [0] - 1 если дискриминант переполнен
                        0 если нет
                  [1] - x_1
                  [2] - x_2
                  [3] - количество корней
==========================================================================
*/
 int main(void)
 {

    setlocale(LC_CTYPE,"Russian"); //Для вывода руских букв

    float a, b, c;   // Определение переменных для коэфициентов уравнения
    double x_1, x_2; // Определение переменных для коней
    int n;           // Определение переменной для количества корней

    // Шапка программы
    printf("==========================================================================\n");
    printf("                   Решение уравнения a*x^2+b*x+c=0                        \n");

    while( abc_scan(&a, &b, &c) == 0)                // Ввод коэфициентов
    {
        if ( abc_lim_over_print ( a, b, c ))         // Проверка коэфициентов
        {;}
        else if (qadrat (a, b, c, &x_1, &x_2, &n ))  // Решение уравнения
        {;}
        else
        {
            x_lim_over_print(x_1, x_2, n);           // Вывод корней
        }
    }

    // оповещение о завершении
    printf("==========================================================================\n");
    printf("Программа завершена\n");
    printf("для закрытия окна нажмите [Enter] \n");
    printf("==========================================================================\n");

    getchar();
    getchar();

 }

 int abc_lim_over_print(float a, float b, float c)
 {
    int n=0; // Количество переполненых чисел
    int out; // Выход функции

    /*начало подсчёт переполненых значений*/
    if (float_lim_over(a))
    {
        n++;
    }
    if (float_lim_over(b))
    {
        n++;
    }
    if (float_lim_over(c))
    {
        n++;
    }
    /*конец подсчёта переполненых значений*/

    /*начало обработки n*/
    if (n==0)
    {
        out = 0;
    }
    else if (n==1)
    {
        /*заготовка для вывода оповещения о переполнении одной пременной*/
        printf("Вы ввели слишком большой(по модулю) коэфициент: ");
    }
    else if (n>1)
    {
        /*заготовка для вывода оповещения о переполнении одной пременной*/
        printf("Вы ввели слишком большие(по модулю) коэфициенты: ");
    }
    /*конец обработки n*/

    /* начало вывода переменных, которые переполнены*/
    if (float_lim_over(a))
    {
        printf("a ");
    }
    if (float_lim_over(b))
    {
        printf("b ");
    }
    if (float_lim_over(c))
    {
        printf("c ");
    }
    /* конец вывода переменных, которые переполнены*/

    /* возврат единици если есть переполнение + вывод символа новой строки, завершающего вывод предупреждения*/
    if (n!=0)
    {
        printf("\n");
        out = 1;
    }

    return out;
 }

 void x_lim_over_print(double x_1, double x_2, int n)
 {
    int np=0; // Количество переполненых чисел
    /*начало подсчёта переполненых значений*/
    if (double_lim_over(x_1))
    {
        np++;
    }
    if (double_lim_over(x_2))
    {
        np++;
    }
    /*конец подсчёта переполненых значений*/

    /*начало обработки np*/
    if (np==0)
    {   /*вывод корней*/
        if ( n==2 )
        {
            printf("Корни уравнения:\n");
            printf("X_1=%f\n", x_1);
            printf("X_2=%f\n", x_2);
        }
        else
        {
            printf("Корень уравнения:\n");
            printf("X = %f\n",x_1);
        }
    }
    else if (np==1)
    {
        /*заготовка для вывода оповещения о переполнении одной пременной*/
        printf("Получилось слишком большое(по модулю) значение: ");
    }
    else if (np>1)
    {
        /*заготовка для вывода оповещения о переполнении одной пременной*/
        printf("Получились слишком большие(по модулю) значения: ");
    }
    /*конец обработки n*/


    /* начало вывода переменных, которые переполнены*/
    if (double_lim_over(x_1))
    {
        printf("x_1 ");
    }
    if (double_lim_over(x_2))
    {
        printf("x_2 ");
    }
    /* конец вывода переменных, которые переполнены*/

    /* вывод символа новой строки для предупреждения об ошибке*/
    if(np)
    {
        printf("\n");
    }

 }

 int qadrat(float a, float b, float c, double *x_1, double *x_2, int *n)
 {
    double Dis;   /*Дискриминант (определён как double чтобы хватало)*/
    double skDis; /*Корень дискриминанта*/
    int out; /*вывод функции*/

    /*Вычисление дискриминанта*/
    Dis = ((b*b)-(4*c*a));

    /*Проверка переполнения Dis*/
     if (double_lim_over(Dis))
    {
        printf("Дискриминант переполнился\n");
        out = 1;
    }

    /* начало ветвления резуультатов в зависимости от дискрииминанта*/
    else if (Dis<0)
    {
        printf("Корней нет\n");
        out=1;
    }
    else
    {
        /*Корень дискриминанта*/
        skDis = sqrt(Dis);

        /*вычисление x_1 и x_2*/
        *x_1 = ((-b + skDis)/(2*a));
        *x_2 = ((-b - skDis)/(2*a));

        /*звпись *n, соответствующего дискриминанту */
        if ((0.0001-Dis)>0)
        {
            *n=1;
            out=0;
        }
        else
        {
            *n=2;
            out=0;
        }
    }

    /*Ввывод значения*/
        return out;

 }

 int float_lim_over(float num)
 {
    int out;
    if ((-FLT_MAX<num) and (num<FLT_MAX))
    {
        out = 0;
    }
    else
    {
        out = 1;
    }

    return out;
 }

 int abc_scan(float *a, float *b, float *c)
 {
    int end_chek=0;      // Вывод программы инициализирующий её завершение
    int eror_rezist=1;   // Значение, которое нужно для возможности возобновления ввода в случае
                         // если попытка её завершить была случайной
    char pr_end_Y_N;     // Значение для записи ввода ответа на вопрос о завершении программы

    while(eror_rezist)
    {
        eror_rezist=0;

        printf("==========================================================================\n");

        printf("Введите коэффициенты (для завершения программы введите любой символ):");

        printf("\na = ");

        // Ввод a, b, c и проверка ввода на ошибки/завершение программы
        if (scanf("%f",&*a))
        {
            printf("b = ");
            if (scanf("%f",&*b))
            {
                printf("c = ");
                if(scanf("%f",&*c))
                {
                    ;
                }
                else
                {
                    end_chek=1;
                    eror_rezist=1;
                }
            }
            else
            {
                end_chek=1;
                eror_rezist=1;
            }
        }
        else
        {
            end_chek=1;
            eror_rezist=1;
        }

        printf("--------------------------------------------------------------------------\n");

        while(end_chek)
        {
            printf("Вы действительно хотите завершить программу [Y/N]: "); //проверка на ошибку пользователя

            //очистка буфера ввода
            while (getchar()!='\n')
            {;}

            pr_end_Y_N = getchar();                         //Запись ответа по первому символу

            //Проверка ответа
            if ((pr_end_Y_N=='Y') || (pr_end_Y_N=='y'))
            {
                eror_rezist=0;
                break;
            }
            else if((pr_end_Y_N=='N') || (pr_end_Y_N=='n'))
            {
                end_chek=0;
                break;
            }
            else
            {
                printf("Я не понял, давй заново\n");
            }
        }
    }


    return end_chek;

 }

 int double_lim_over(double num)
 {
    int out;
    if ((-DBL_MAX<num) and (num<DBL_MAX))
    {
        out = 0;
    }
    else
    {
        out = 1;
    }

    return out;
 }
