 #include <stdio.h>
 #include <locale.h>
 #include <stdbool.h>
 #include <limits.h>
 #include <float.h>
 #include <math.h>

 int double_lim_over(double num);
/*нужно написать
*/
 int float_lim_over(float num);
/*
==========================================================================
                      int float_lim_over(float num)
==========================================================================
Проверяет, переполнено число или нет
==========================================================================
Ввод:
num      число для проверки
Вывод:
int      1 - если число переполнено
         0 - если нет
==========================================================================
*/
 int abc_lim_over_print(float a, float b, float c);
/*
==========================================================================
             int abc_lim_over_print(float a,float b,float c);
==========================================================================
Проверяет a, b, c на переполнение и выводит оповещение пользователю о
преполненых элементах
==========================================================================
Ввод:
a, b, c  float значения коэфициентов квадратного уравнения.
Вывод:
int      0 если нет переполненных элементов
         1 если есть
printf   Печатает на экран предупреждение о слишком больших/малых
         введённых значениях
==========================================================================
*/
 void x_lim_over_print(double x_1, double x_2, int n);
/*
==========================================================================
              int x_lim_over_print(float x_1, float x_2);
==========================================================================
Проверяет x_1 x_2 на переполнение и выводит оповещение пользователю о
преполненых элементах bkb x_1 x_2
==========================================================================
Ввод:
x_1, x_2 float значения коэфициентов квадратного уравнения.
n        int   количество корней
Вывод:
int      0 если нет переполненных элементов
         1 если есть
printf   Печатает на экран предупреждение о слишком больших значениях
         корней или выводит их
==========================================================================
*/
 int qadrat ( float a, float b, float c, double *x_1, double *x_2, int *n );
/*нужно переделать
==========================================================================
    int qadrat(float a, float b, float c, float x_1, float x_2, int n);
==========================================================================
Решает ax^2+bx+c=0 и проверяет дискриминант на переполнение
==========================================================================
Ввод:
a, b, c  float значения коэфициентов квадратного уравнения
x_1, x_2 float пустые значения для указаниякорней уравнения
Вывод:
float    Массив: [0] - 1 если дискриминант переполнен
                       0 если нет
                 [1] - x_1
                 [2] - x_2
                 [3] - оличество корней
==========================================================================
*/
 int main(void)
 {
    setlocale(LC_CTYPE,"Russian");
    float a, b, c; /*Определение переменных для коэфициентов уравнения и его корней */
    double x_1, x_2;
    int n;
    printf("Введите a, b, c через пробел");
    scanf("%f %f %f", &a, &b, &c);
    if ( abc_lim_over_print ( a, b, c ))
    {;}
    else if (qadrat (a, b, c, &x_1, &x_2, &n ))
    {
    x_lim_over_print(x_1, x_2, n);
    }
 }

 int abc_lim_over_print(float a, float b, float c)
 {
    int n=0; // Количество переполненых чисел
    int out; // Выход функции

    /*начало подсчёт переполненых значений*/
    if (float_lim_over(a))
    {
        n++;
    }
    if (float_lim_over(b))
    {
        n++;
    }
    if (float_lim_over(c))
    {
        n++;
    }
    /*конец подсчёта переполненых значений*/

    /*начало обработки n*/
    if (n==0)
    {
        out = 0;
    }
    else if (n==1)
    {
        /*заготовка для вывода оповещения о переполнении одной пременной*/
        printf("Вы ввели слишком большой коэфициент ");
    }
    else if (n>1)
    {
        /*заготовка для вывода оповещения о переполнении одной пременной*/
        printf("Вы ввели слишком большие коэфициенты ");
    }
    /*конец обработки n*/

    /* начало вывода переменных, которые переполнены*/
    if (float_lim_over(a))
    {
        printf("a ");
    }
    if (float_lim_over(b))
    {
        printf("b ");
    }
    if (float_lim_over(c))
    {
        printf("c ");
    }
    /* конец вывода переменных, которые переполнены*/

    /* возврат единици если есть переполнение*/
    if (n!=0)
    {
        out = 1;
    }

    return out;
 }

 void x_lim_over_print(double x_1, double x_2, int n)
 {
    int np=0; // Количество переполненых чисел
    /*начало подсчёта переполненых значений*/
    if (double_lim_over(x_1))
    {
        np++;
    }
    if (double_lim_over(x_2))
    {
        np++;
    }
    /*конец подсчёта переполненых значений*/

    /*начало обработки np*/
    if (np==0)
    {   /*вывод корней*/
        if ( n==2 )
        {
            printf("Корни уравнения x_1=%f x_2=%f",x_1,x_2);
        }
        else
        {
            printf("Корень уравнения %f",x_1);
        }
    }
    else if (np==1)
    {
        /*заготовка для вывода оповещения о переполнении одной пременной*/
        printf("Вы ввели слишком большой коэфициент ");
    }
    else if (np>1)
    {
        /*заготовка для вывода оповещения о переполнении одной пременной*/
        printf("Вы ввели слишком большие коэфициенты ");
    }
    /*конец обработки n*/


    /* начало вывода переменных, которые переполнены*/
    if (double_lim_over(x_1))
    {
        printf("x_1 ");
    }
    if (double_lim_over(x_2))
    {
        printf("x_2 ");
    }
    /* конец вывода переменных, которые переполнены*/

    /* возврат единици если есть переполнение*/
    if (np!=0)
    {
    }
 }

 int qadrat(float a, float b, float c, double *x_1, double *x_2, int *n)
 {
    double Dis;   /*Дискриминант (определён как double чтобы хватало)*/
    double skDis; /*Корень дискриминанта*/
    int out; /*вывод функции*/

    /*Вычисление дискриминанта*/
    Dis = ((b*b)-(4*c*a));

    /*Проверка переполнения Dis*/
     if (double_lim_over(Dis))
    {
        printf("Переполнение дискриминанта");
        out = 1;
    }

    /* начало ветвления резуультатов в зависимости от дискрииминанта*/
    else if (Dis<0)
    {
        printf("Корней нет");
        out=1;
    }
    else
    {
        /*Корень дискриминанта*/
        skDis = sqrt(Dis);

        /*вычисление x_1 и x_2*/
        *x_1 = ((-b + skDis)/(2*a));
        *x_2 = ((-b - skDis)/(2*a));

        /*звпись *n, соответствующего дискриминанту */
        if ((0.0001-Dis)>0)
        {
            *n=1;
            out=0;
        }
        else
        {
            *n=2;
            out=0;
        }
    }

    /*Ввывод значения*/
        return out;

 }

 int float_lim_over(float num)
 {
    int out;
    if ((-FLT_MAX<num) and (num<FLT_MAX))
    {
        out = 0;
    }
    else
    {
        out = 1;
    }

    return out;
 }

 int double_lim_over(double num)
 {
    int out;
    if ((-DBL_MAX<num) and (num<DBL_MAX))
    {
        out = 0;
    }
    else
    {
        out = 1;
    }

    return out;
 }
